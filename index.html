<style>
  * {font-family: Helvetica, Arial}
  table.syntax tr td {
    font-family: Consolas, Menlo, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
    vertical-align: middle;
  }
  pre {
    font-family: Consolas, Menlo, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', monospace;
  }
  </style>
<h1>Peppermint Expressions</h1>

<p><i>
Syntax for your programming language.
</i> <a href="http://github.com/drewlesueur/peppermint-expressions">source on github</a></p>

<p>
Peppermint Expressions are like
<a href="http://en.wikipedia.org/wiki/S-expression#Example_of_source_code_s-expressions">
S-expressions</a> but with a few extras.
<p>
This project includes a parser written in 
JavaScript that converts the expressions to
a nested JavaScript array.
You, as a language designer, can then take that array and do whatever you want with it,
 interperet it, compile it, apply macros to it.
</p>

<h2>Usage</h2>
<p>Peppermint-exression relies on the extremely simple poor_module</p>
<h4>Browser</h4>
<pre>
&lt;script src="poor_modules/poor-module.js"&gt;&lt;/script&gt;
&lt;script src="peppermint-expressions.js"&gt;&lt;/script&gt;
&lt;script &gt;
// poor_module gives you a global getModule
var peppermint = getModule("peppermint-expressions")
console.log(peppermint('say "hello world!"'))
&lt;/script&gt;
</pre>
<h4>node.js</h4>
<pre>
require("./poor_modules/poor_module.js")
require("./peppermint-expressions.js")
peppermint = getModule("peppermint-expressions")
console.log(peppermint('say "hello world!"'))
&lt;script &gt;
// poor_module gives you a global getModule
var peppermint = getModule("peppermint-expressions")
console.log(peppermint('say "hello world!"'))
&lt;/script&gt;
</pre>
</p>

<table class="syntax" border="1" style="border-collapse: collapse;" cellpadding="5" >
  <thead>
  <tr>
    <th width="33%">
      Peppermint Expression
    </th>
    <th width="33%">
      JSON Equivalent<sub><a href="#1">1</a></sub>
    </th>
    <th width="33%">
     Notes
    </th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>hello</td>
    <td>"hello"</td>
    <td>Simple identifier</td>
  </tr>
  <tr>
    <td>"hello"</td>
    <td>"'hello"</td>
    <td>text</td>
  </tr>
  <tr>
    <td>(say "hello")</td>
    <td rowspan="5">["say","'hello"]</td>
    <td>function call Lisp-like</td>
  </tr>
  <tr>
    <td>say("hello")</td>
    <td>function call C-like</td>
  </tr>
  <tr>
    <td>say: "hello"</td>
    <td>function call wanna-be-coffeescript-like</td>
  </tr>
  <tr>
    <td>say.hello</td>
    <td></td>
  </tr>
  <tr>
    <td>say . hello</td>
    <td></td>
  </tr>
  <tr>
    <td>(say "hello" name)</td>
    <td rowspan="3">["say","'hello","name"]</td>
    <td>function call Lisp-like</td>
  </tr>
  <tr>
    <td>say("hello" name)</td>
    <td>function call C-like</td>
  </tr>
  <tr>
    <td>say: "hello" name</td>
    <td>function call wanna-be-coffeescript-like</td>
  </tr>
  <tr>
    <td>(add (multiply m x) b)</td>
    <td rowspan="2">["add",["multiply","m","x"],"b"]</td>
    <td>nested expressions. Lisp-like</td>
  </tr>
  <tr>
    <td>add(multiply(m x) b)</td>
    <td>alternate syntax. C-like </td>
  </tr>
  <tr>
    <td>items.map(add-one).filter(only-evens).each(say)</td>
    <td rowspan="1">[[[[[["items","'map"],"add-one"],"'filter"],"only-evens"],"'each"],"say"]</td>
    <td>C-like with dot notation caining</td>
  </tr>
  <tr>
    <td>say: capitalize: "star trek"</td>
    <td rowspan="2">["say",["capitalize","'star trek"]]</td>
    <td>Coffeescript-ish function calls (note the colon)</td>
  </tr>
  <tr>
    <td>:say :capitalize "star trek"</td>
    <td>colon can be on either side just like parens</td>
  </tr>
  <tr>
    <td><pre>
invite-friends: list: "aimee" "drew"
  "jewel" "grace"
    </pre></td>
    <td rowspan="1">["invite-friends",["list","'aimee","'drew","'jewel","'grace"]]</td>
    <td>Coffeescript-ish function calls (note the colon)</td>
  </tr>
  <tr>
    <td><pre>
party:
  name: "Cool party"
  music: "Aterciopelados" "javera mena" 
  attendees:
    drew: name("drew") age(27)
    aimee
  food:
    dessert: ice cream
    dinner: pizza
    snack: popcorn
    
    </pre></td>
    <td rowspan="1">["party",["name","'Cool party"],["music","'Aterciopelados","'javera mena"],["attendees",["drew",["name","'drew"],["age","27"]],"aimee"],["food",["dessert","ice","cream"],["dinner","pizza"],["snack","popcorn"]]]</td>
    <td>longer nesting. Probably for use with a macro in your language</td>
  </tr>
  <tr>
    <td><pre>
log(json.parse: db.get: key)
log("hi")
    </pre></td>
    <td rowspan="1">["log",[["json","'parse"],[["db","'get"],"key"]]],["log","'hi"]</td>
    <td>colon with parens</td>
  </tr>
  <tr>
    <td><pre>
(get func)("fast")
    </pre></td>
    <td rowspan="3">[["get","func"],"'fast"]</td>
    <td>call a call</td>
  </tr>
  <tr>
    <td><pre>
(get func).fast
    </pre></td>
    <td>dot notation after parens</td>
  </tr>
  <tr>
    <td><pre>
get(func).fast
    </pre></td>
    <td>dot notation after parens</td>
  </tr>
  <tr>
    <td><pre>
(get func).fast(200)
    </pre></td>
    <td rowspan="1">[[["get","func"],"'fast"],"200"]</td>
    <td>dot notation after parens, with method call</td>
  </tr>
  <tr>
    <td><pre>
say: extra
  space at end
    </pre></td>
    <td rowspan="1">["say","extra","space","at","end"]</td>
    <td>note the space after the tick</td>
  </tr>
  <tr>
    <td><pre>
"multi line
strings"
    </pre></td>
    <td rowspan="1">"'multi line\nstrings"</td>
    <td>multi-line strings</td>
  </tr>
  <tr>
    <td><pre>
randomword"multi line
strings with quotes " inside "randomword
    </pre></td>
    <td rowspan="1">"'multi line\nstrings with quotes \" inside "</td>
    <td></td>
  </tr>
  <tr>
    <td><pre>
'single-quoted-string
    </pre></td>
    <td rowspan="1">"'single-quoted-string"</td>
    <td></td>
  </tr>
  <tr>
    <td><pre>
"'string with a single quote at the beginning"
    </pre></td>
    <td rowspan="1">"''string with a single quote at the beginning"</td>
    <td></td>
  </tr>

  <tr>
    <td><pre>
' indention
  based string
       way more indented
</pre></td>
    <td rowspan="1">"indention\n  based string\n       way more indented"</td>
    <td>note the space after the tick</td>
  </tr>
  <tr>
    <td><pre>
say: ' hello world
     my name is peppermint
  whats yours?
say: ' goodbye world
</pre></td>
  <td rowspan="1"><pre>["say","hello world\n     my name is peppermint\n  whats yours?"],["say","goodbye world"]</pre></td>
    <td>note the space after the tick</td>
  </tr>
  <tr>
    <td><pre>
say: '
  dont include first carriage return
</pre></td>
    <td rowspan="1">["say","dont include first carriage return"]</td>
    <td>note the space after the tick</td>
  </tr>
  <tr>
    <td><pre>
say: '
        dont include first carriage return
  hanlde wierd indents
</pre></td>
    <td rowspan="1">["say","      dont include first carriage return\nhanlde wierd indents"]</td>
    <td>note the space after the tick</td>
  </tr>
  <tr>
    <td><pre>
say: 
  capitalize: '
    this is
    an indented string
say: ' it handled it
</pre></td>
    <td rowspan="1">["say",["capitalize","this is\nan indented string"],["say","it handled it"]]</td>
    <td>more indentation</td>
  </tr>
  <tr>
    <td><pre>
build(
  house
  pool
  address: "123 E real st"
  mailbox
)
</pre></td>
    <td rowspan="1">["build","house","pool",["address","'123 E real st"],"mailbox"]</td>
    <td>parens on more than one line</td>
  </tr>
  <tr>
    <td><pre>
$("body")
  .append(divs)
  .css("background-color" "red")
    </pre></td>
    <td rowspan="1">[[[[["$","'body"],"'append"],"divs"],"'css"],"'background-color","'red"]</td>
    <td>pretty chaining</td>
  </tr>
  </tbody>
</table>

<a name="1"><b>1</b></a> 
Not including surrounding array brackets

<script src="zepto.min.js"></script>
<script src="poor_modules/poor-module.js"></script>
<script src="peppermint-expressions.js"></script>
<script>
  var convertHtmlTableToArray = function (table) {
    table = $(table)
    headers = []
    table.find("thead th").each(function() {
      headers.push($.trim($(this).text()))
    })
    var tbody = table.find("tbody")
    var vspanMap = {}
    var ret = []

    tbody.find("tr").each(function (trIndex, tr) {
      var row = []
      $(tr).find("td").each(function (tdIndex, td) {
        td = $(td);
        var value = $(td).text()
        row.push(value)
      }) 
      ret.push(row)
    })


    tbody.find("tr").each(function (trIndex, tr) {
      var row = ret[trIndex]
      $(tr).find("td").each(function (tdIndex, td) {
        td = $(td);
        rowspan = td.attr("rowspan") - 0
        rowspan0index = rowspan - 1
        if (rowspan0index > 0) {
          for (var i = 1; i <= rowspan0index; i++) {
            newRow = ret[trIndex + i] 
            newRow.splice(tdIndex, 0, row[tdIndex])
          }   
        }
      }) 
    })


    var ret2 = [] 
    for (var i = 0; i < ret.length; i++) { 
      row = ret[i] 
      var row2 = {} 
      for (var j = 0; j < headers.length; j++) {
        var header = headers[j]
        row2[header] = row[j]
      }
      ret2.push(row2)
    }

    return ret2

  }
  var peppermint = getModule("peppermint-expressions")
  var runTests = function () {
    var tableArray = convertHtmlTableToArray("table");

    for (var i = 0; i < tableArray.length; i++) {
      var row = tableArray[i];
      try {
        json = JSON.stringify(peppermint(row["Peppermint Expression"]))
          .slice(1).slice(0, -1) //get rid of surrounding brackets
        if (json == row["JSON Equivalent1"]) {
          $("table tbody tr").eq(i).find("td").eq(0).css("background-color", "lightgreen")
        } else {
          $("table tbody tr").eq(i).find("td").eq(0).css("background-color", "pink")
          .append("<pre>////" + json + "</pre>")
        }
      } catch (e) {
          //$("table tbody tr").eq(i).find("td").eq(1).css("background-color", "lightred")
          console.log(e)
          throw e
          continue
      }
    }
    console.log(tableArray)
  }
  runTests()
</script>

